name: PR Analysis and Review

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  analyze:
    runs-on: ubuntu-latest
    environment: prod
    steps:
      # Keep existing checkout and setup steps
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        id: eslint
        continue-on-error: true
        run: |
          echo "Running ESLint analysis..."
          npx eslint . --format json --output-file eslint-results.json || true
          
          # Contar errores y warnings
          ERRORS=$(jq '[.[].messages[] | select(.severity == 2)] | length' eslint-results.json 2>/dev/null || echo "0")
          WARNINGS=$(jq '[.[].messages[] | select(.severity == 1)] | length' eslint-results.json 2>/dev/null || echo "0")
          
          echo "eslint_errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "eslint_warnings=$WARNINGS" >> $GITHUB_OUTPUT
          
          if [ "$ERRORS" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
            echo "ESLint found $ERRORS errors and $WARNINGS warnings"
          else
            echo "ESLint: No issues found"
          fi

      - name: Run Tests
        id: tests
        continue-on-error: true
        run: |
          echo "Running tests..."
          npm test -- --coverage --json --outputFile=test-results.json || true
          
          # Extraer resultados de tests
          if [ -f "test-results.json" ]; then
            PASSED=$(jq '.numPassedTests // 0' test-results.json)
            FAILED=$(jq '.numFailedTests // 0' test-results.json)
            COVERAGE=$(jq '.coverageMap // {} | keys | length' test-results.json)
          else
            PASSED=0
            FAILED=0
            COVERAGE=0
          fi
          
          echo "tests_passed=$PASSED" >> $GITHUB_OUTPUT
          echo "tests_failed=$FAILED" >> $GITHUB_OUTPUT
          echo "coverage_files=$COVERAGE" >> $GITHUB_OUTPUT

      - name: Security Audit
        id: audit
        continue-on-error: true
        run: |
          echo "Running security audit..."
          npm audit --json > audit-results.json || true
          
          # Contar vulnerabilidades por severidad
          HIGH=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "high") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
          MODERATE=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "moderate") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
          
          echo "audit_high=$HIGH" >> $GITHUB_OUTPUT
          echo "audit_moderate=$MODERATE" >> $GITHUB_OUTPUT

      - name: Check Code Formatting
        id: prettier
        continue-on-error: true
        run: |
          echo "Checking code formatting..."
          npx prettier --check . > prettier-results.txt 2>&1 || true
          
          if [ $? -eq 0 ]; then
            echo "formatting_issues=0" >> $GITHUB_OUTPUT
          else
            ISSUES=$(cat prettier-results.txt | grep -c "Code style issues found" || echo "1")
            echo "formatting_issues=$ISSUES" >> $GITHUB_OUTPUT
          fi

      - name: Get PR diff
        id: diff
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git fetch origin ${{ github.event.pull_request.head.ref }}
          git diff ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > pr_diff.txt
          
          # Analizar estadÃ­sticas del diff
          echo "Analyzing PR changes..."
          
          # Contar archivos modificados
          FILES_CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | wc -l)
          
          # Contar lÃ­neas agregadas y eliminadas
          DIFF_STATS=$(git diff --numstat ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          LINES_ADDED=$(echo "$DIFF_STATS" | awk '{sum += $1} END {print sum+0}')
          LINES_DELETED=$(echo "$DIFF_STATS" | awk '{sum += $2} END {print sum+0}')
          
          # Obtener lista de archivos por tipo
          MODIFIED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          JS_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' | wc -l || echo "0")
          CSS_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(css|scss|sass|less)$' | wc -l || echo "0")
          JSON_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.json$' | wc -l || echo "0")
          MD_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.md$' | wc -l || echo "0")
          CONFIG_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(yml|yaml|xml|config|env)$' | wc -l || echo "0")
          OTHER_FILES=$((FILES_CHANGED - JS_FILES - CSS_FILES - JSON_FILES - MD_FILES - CONFIG_FILES))
          
          # Generar resumen de cambios por archivo
          echo "## ðŸ“ Files Changed:" > pr_changes_summary.txt
          echo "" >> pr_changes_summary.txt
          echo "$MODIFIED_FILES" | head -20 | while read file; do
            if [ ! -z "$file" ]; then
              # Obtener stats por archivo
              FILE_STATS=$(git diff --numstat ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file")
              ADDED=$(echo "$FILE_STATS" | awk '{print $1}')
              DELETED=$(echo "$FILE_STATS" | awk '{print $2}')
              
              # Determinar el tipo de cambio
              if git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^A"; then
                STATUS="ðŸ†• Added"
              elif git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^D"; then
                STATUS="ðŸ—‘ï¸ Deleted"
              elif git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^R"; then
                STATUS="ðŸ“ Renamed"
              else
                STATUS="âœï¸ Modified"
              fi
              
              echo "- **$file** $STATUS (+$ADDED/-$DELETED)" >> pr_changes_summary.txt
            fi
          done
          
          if [ $FILES_CHANGED -gt 20 ]; then
            echo "- ... and $((FILES_CHANGED - 20)) more files" >> pr_changes_summary.txt
          fi
          
          # Generar resumen inteligente del propÃ³sito del PR
          echo "" > pr_purpose_summary.txt
          echo "## ðŸ“ PR Summary" >> pr_purpose_summary.txt
          echo "" >> pr_purpose_summary.txt
          
          # Analizar patrones en los archivos para determinar el propÃ³sito
          PURPOSE=""
          DETAILS=""
          
          # Detectar cambios en CI/CD
          if echo "$MODIFIED_FILES" | grep -q "\.github/workflows"; then
            PURPOSE="CI/CD Pipeline Configuration"
            DETAILS="This PR modifies GitHub Actions workflows for continuous integration and deployment."
          elif echo "$MODIFIED_FILES" | grep -q "Dockerfile\|docker-compose"; then
            PURPOSE="Docker Configuration"
            DETAILS="This PR updates Docker containerization setup."
          elif echo "$MODIFIED_FILES" | grep -q "package\.json\|yarn\.lock\|package-lock\.json"; then
            if [ $JS_FILES -gt 0 ]; then
              PURPOSE="Feature Development & Dependencies"
              DETAILS="This PR includes new features or updates along with dependency changes."
            else
              PURPOSE="Dependency Updates"
              DETAILS="This PR focuses on updating project dependencies."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "\.test\.\|\.spec\.\|__tests__"; then
            PURPOSE="Testing & Quality Assurance"
            DETAILS="This PR adds or improves test coverage and quality assurance."
          elif echo "$MODIFIED_FILES" | grep -q "README\|\.md$"; then
            if [ $FILES_CHANGED -eq $MD_FILES ]; then
              PURPOSE="Documentation Update"
              DETAILS="This PR focuses on improving project documentation."
            else
              PURPOSE="Feature Development with Documentation"
              DETAILS="This PR includes feature changes along with documentation updates."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "\.css\|\.scss\|\.sass\|\.less"; then
            if [ $CSS_FILES -eq $FILES_CHANGED ]; then
              PURPOSE="UI/UX Styling Updates"
              DETAILS="This PR focuses on user interface and styling improvements."
            else
              PURPOSE="Feature Development with UI Changes"
              DETAILS="This PR includes functionality changes with user interface updates."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "config\|\.env\|\.yml\|\.yaml\|\.xml"; then
            PURPOSE="Configuration Updates"
            DETAILS="This PR modifies application or environment configuration."
          elif [ $JS_FILES -gt 0 ]; then
            if [ $FILES_CHANGED -le 3 ]; then
              PURPOSE="Bug Fix or Minor Enhancement"
              DETAILS="This PR addresses specific issues or makes targeted improvements."
            else
              PURPOSE="Feature Development"
              DETAILS="This PR introduces new functionality or significant enhancements."
            fi
          else
            PURPOSE="General Updates"
            DETAILS="This PR contains miscellaneous updates and improvements."
          fi
          
          # Agregar informaciÃ³n especÃ­fica basada en archivos
          SPECIFIC_CHANGES=""
          if echo "$MODIFIED_FILES" | grep -q "\.github/workflows.*\.yml"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ”„ GitHub Actions workflow automation"
          fi
          if echo "$MODIFIED_FILES" | grep -q "package\.json"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ“¦ NPM dependencies and scripts"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.js\|\.jsx\|\.ts\|\.tsx"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ’» JavaScript/TypeScript code changes"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.css\|\.scss"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸŽ¨ Styling and visual updates"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.test\.\|\.spec\."; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ§ª Test cases and quality assurance"
          fi
          if echo "$MODIFIED_FILES" | grep -q "README\|\.md"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ“š Documentation improvements"
          fi
          if echo "$MODIFIED_FILES" | grep -q "Dockerfile\|docker"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- ðŸ³ Docker containerization"
          fi
          
          echo "**Purpose:** $PURPOSE" >> pr_purpose_summary.txt
          echo "" >> pr_purpose_summary.txt
          echo "$DETAILS" >> pr_purpose_summary.txt
          
          if [ ! -z "$SPECIFIC_CHANGES" ]; then
            echo "" >> pr_purpose_summary.txt
            echo "**Key Changes:**" >> pr_purpose_summary.txt
            echo -e "$SPECIFIC_CHANGES" >> pr_purpose_summary.txt
          fi
          
          # Guardar estadÃ­sticas en outputs
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT
          echo "lines_added=$LINES_ADDED" >> $GITHUB_OUTPUT
          echo "lines_deleted=$LINES_DELETED" >> $GITHUB_OUTPUT
          echo "js_files=$JS_FILES" >> $GITHUB_OUTPUT
          echo "css_files=$CSS_FILES" >> $GITHUB_OUTPUT
          echo "json_files=$JSON_FILES" >> $GITHUB_OUTPUT
          echo "md_files=$MD_FILES" >> $GITHUB_OUTPUT
          echo "config_files=$CONFIG_FILES" >> $GITHUB_OUTPUT
          echo "other_files=$OTHER_FILES" >> $GITHUB_OUTPUT

      - name: Generate PR Comment
        id: copilot
        run: |
          {
            echo "ðŸ¤– **Automated Code Review Summary**"
            echo ""
            echo "## ðŸ“Š Analysis Results"
            echo ""
            echo "### ðŸ” ESLint Analysis"
            echo "- âŒ Errors: ${{ steps.eslint.outputs.eslint_errors }}"
            echo "- âš ï¸ Warnings: ${{ steps.eslint.outputs.eslint_warnings }}"
            echo ""
            echo "### ðŸ§ª Test Results"
            echo "- âœ… Passed: ${{ steps.tests.outputs.tests_passed }}"
            echo "- âŒ Failed: ${{ steps.tests.outputs.tests_failed }}"
            echo "- ðŸ“Š Coverage: ${{ steps.tests.outputs.coverage_files }} files"
            echo ""
            echo "### ðŸ”’ Security Audit"
            echo "- ðŸš¨ High: ${{ steps.audit.outputs.audit_high }}"
            echo "- âš ï¸ Moderate: ${{ steps.audit.outputs.audit_moderate }}"
            echo ""
            echo "### ðŸ’… Code Formatting"
            echo "- ðŸ“ Issues: ${{ steps.prettier.outputs.formatting_issues }}"
            echo ""
            echo "## ðŸŽ¯ Recommendations"
            echo ""
            if [ '${{ steps.eslint.outputs.eslint_errors }}' -gt 0 ]; then
              echo "- ðŸ”§ Fix ESLint errors before merging"
            fi
            if [ '${{ steps.tests.outputs.tests_failed }}' -gt 0 ]; then
              echo "- ðŸ§ª Fix failing tests"
            fi
            if [ '${{ steps.audit.outputs.audit_high }}' -gt 0 ]; then
              echo "- ðŸš¨ Address high security vulnerabilities"
            fi
            if [ '${{ steps.prettier.outputs.formatting_issues }}' -gt 0 ]; then
              echo "- ðŸ’… Run prettier to fix formatting"
            fi
          } > review_comment.txt
          
          # Convert to single line for GitHub output
          COMMENT=$(cat review_comment.txt | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "comment=$COMMENT" >> $GITHUB_OUTPUT

      - name: Post Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `${{ steps.copilot.outputs.comment }}`.replace(/\\n/g, '\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });

