name: PR Analysis and Review

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  analyze:
    runs-on: ubuntu-latest
    environment: prod
    steps:
      # Keep existing checkout and setup steps
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            echo "Installing dependencies..."
            npm ci --no-audit --no-fund --ignore-scripts
          else
            echo "No package.json found, skipping npm install"
          fi

      - name: Validate project structure
        run: |
          echo "Validating project structure..."
          echo "üì¶ Package.json exists: $([ -f "package.json" ] && echo "‚úÖ" || echo "‚ùå")"
          echo "üîß ESLint config: $([ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] && echo "‚úÖ" || echo "‚ùå")"
          echo "üíÖ Prettier config: $([ -f ".prettierrc" ] || [ -f ".prettierrc.json" ] && echo "‚úÖ" || echo "‚ùå")"
          echo "üß™ Jest config: $([ -f "jest.config.js" ] && echo "‚úÖ" || echo "‚ùå")"
          
          if [ -f "package.json" ]; then
            echo "üìú Available npm scripts:"
            jq -r '.scripts | keys[]' package.json 2>/dev/null || echo "No scripts found"
          fi

      - name: Run Code Quality Checks
        id: quality
        continue-on-error: true
        run: |
          echo "Running code quality analysis..."
          
          # Inicializar variables
          ESLINT_ERRORS=0
          ESLINT_WARNINGS=0
          TESTS_PASSED=0
          TESTS_FAILED=0
          COVERAGE_FILES=0
          AUDIT_HIGH=0
          AUDIT_MODERATE=0
          FORMATTING_ISSUES=0
          
          # Verificar si existe package.json antes de continuar
          if [ ! -f "package.json" ]; then
            echo "No package.json found, skipping all npm-based checks..."
            echo "eslint_errors=0" >> $GITHUB_OUTPUT
            echo "eslint_warnings=0" >> $GITHUB_OUTPUT
            echo "tests_passed=0" >> $GITHUB_OUTPUT
            echo "tests_failed=0" >> $GITHUB_OUTPUT
            echo "coverage_files=0" >> $GITHUB_OUTPUT
            echo "audit_high=0" >> $GITHUB_OUTPUT
            echo "audit_moderate=0" >> $GITHUB_OUTPUT
            echo "formatting_issues=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # ESLint solo si existe configuraci√≥n Y script
          if ([ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f "eslint.config.js" ]) && jq -e '.scripts.lint' package.json > /dev/null 2>&1; then
            echo "Running ESLint analysis..."
            npm run lint -- --format json --output-file eslint-results.json 2>/dev/null || true
            
            if [ -f "eslint-results.json" ]; then
              ESLINT_ERRORS=$(jq '[.[].messages[] | select(.severity == 2)] | length' eslint-results.json 2>/dev/null || echo "0")
              ESLINT_WARNINGS=$(jq '[.[].messages[] | select(.severity == 1)] | length' eslint-results.json 2>/dev/null || echo "0")
            fi
          elif [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f "eslint.config.js" ]; then
            echo "ESLint config found but no 'lint' script in package.json, running directly..."
            npx eslint . --format json --output-file eslint-results.json 2>/dev/null || true
            
            if [ -f "eslint-results.json" ]; then
              ESLINT_ERRORS=$(jq '[.[].messages[] | select(.severity == 2)] | length' eslint-results.json 2>/dev/null || echo "0")
              ESLINT_WARNINGS=$(jq '[.[].messages[] | select(.severity == 1)] | length' eslint-results.json 2>/dev/null || echo "0")
            fi
          else
            echo "ESLint configuration not found, skipping..."
          fi
          
          # Tests solo si existe script de test
          if jq -e '.scripts.test' package.json > /dev/null 2>&1; then
            echo "Running tests..."
            npm test -- --coverage --json --outputFile=test-results.json 2>/dev/null || true
            
            if [ -f "test-results.json" ]; then
              TESTS_PASSED=$(jq '.numPassedTests // 0' test-results.json 2>/dev/null || echo "0")
              TESTS_FAILED=$(jq '.numFailedTests // 0' test-results.json 2>/dev/null || echo "0")
              COVERAGE_FILES=$(jq '.coverageMap // {} | keys | length' test-results.json 2>/dev/null || echo "0")
            fi
          else
            echo "No test script found in package.json, skipping tests..."
          fi
          
          # Security audit
          echo "Running security audit..."
          npm audit --json > audit-results.json 2>/dev/null || true
          
          if [ -f "audit-results.json" ]; then
            AUDIT_HIGH=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "high") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
            AUDIT_MODERATE=$(jq '.vulnerabilities | to_entries[] | select(.value.severity == "moderate") | .key' audit-results.json 2>/dev/null | wc -l || echo "0")
          fi
          
          # Prettier solo si existe configuraci√≥n Y script
          if ([ -f ".prettierrc" ] || [ -f ".prettierrc.json" ] || [ -f "prettier.config.js" ]) && jq -e '.scripts.format' package.json > /dev/null 2>&1; then
            echo "Checking code formatting with npm script..."
            npm run format:check > prettier-results.txt 2>&1 || PRETTIER_EXIT_CODE=$?
            
            if [ "${PRETTIER_EXIT_CODE:-0}" -ne 0 ]; then
              FORMATTING_ISSUES=$(cat prettier-results.txt | wc -l || echo "1")
            fi
          elif [ -f ".prettierrc" ] || [ -f ".prettierrc.json" ] || [ -f "prettier.config.js" ]; then
            echo "Prettier config found but no 'format' script, checking directly..."
            npx prettier --check . > prettier-results.txt 2>&1 || PRETTIER_EXIT_CODE=$?
            
            if [ "${PRETTIER_EXIT_CODE:-0}" -ne 0 ]; then
              FORMATTING_ISSUES=$(cat prettier-results.txt | wc -l || echo "1")
            fi
          else
            echo "Prettier configuration not found, skipping formatting check..."
          fi
          
          # Guardar outputs
          echo "eslint_errors=$ESLINT_ERRORS" >> $GITHUB_OUTPUT
          echo "eslint_warnings=$ESLINT_WARNINGS" >> $GITHUB_OUTPUT
          echo "tests_passed=$TESTS_PASSED" >> $GITHUB_OUTPUT
          echo "tests_failed=$TESTS_FAILED" >> $GITHUB_OUTPUT
          echo "coverage_files=$COVERAGE_FILES" >> $GITHUB_OUTPUT
          echo "audit_high=$AUDIT_HIGH" >> $GITHUB_OUTPUT
          echo "audit_moderate=$AUDIT_MODERATE" >> $GITHUB_OUTPUT
          echo "formatting_issues=$FORMATTING_ISSUES" >> $GITHUB_OUTPUT
          
          echo "Quality checks completed: $ESLINT_ERRORS errors, $TESTS_FAILED failed tests, $AUDIT_HIGH high vulnerabilities"

      - name: Get PR diff
        id: diff
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git fetch origin ${{ github.event.pull_request.head.ref }}
          git diff ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > pr_diff.txt
          
          # Analizar estad√≠sticas del diff
          echo "Analyzing PR changes..."
          
          # Contar archivos modificados
          FILES_CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | wc -l)
          
          # Contar l√≠neas agregadas y eliminadas
          DIFF_STATS=$(git diff --numstat ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          LINES_ADDED=$(echo "$DIFF_STATS" | awk '{sum += $1} END {print sum+0}')
          LINES_DELETED=$(echo "$DIFF_STATS" | awk '{sum += $2} END {print sum+0}')
          
          # Obtener lista de archivos por tipo
          MODIFIED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          JS_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(js|jsx|ts|tsx)$' | wc -l || echo "0")
          CSS_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(css|scss|sass|less)$' | wc -l || echo "0")
          JSON_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.json$' | wc -l || echo "0")
          MD_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.md$' | wc -l || echo "0")
          CONFIG_FILES=$(echo "$MODIFIED_FILES" | grep -E '\.(yml|yaml|xml|config|env)$' | wc -l || echo "0")
          OTHER_FILES=$((FILES_CHANGED - JS_FILES - CSS_FILES - JSON_FILES - MD_FILES - CONFIG_FILES))
          
          # Generar resumen de cambios por archivo
          echo "## üìÅ Files Changed:" > pr_changes_summary.txt
          echo "" >> pr_changes_summary.txt
          echo "$MODIFIED_FILES" | head -20 | while read file; do
            if [ ! -z "$file" ]; then
              # Obtener stats por archivo
              FILE_STATS=$(git diff --numstat ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file")
              ADDED=$(echo "$FILE_STATS" | awk '{print $1}')
              DELETED=$(echo "$FILE_STATS" | awk '{print $2}')
              
              # Determinar el tipo de cambio
              if git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^A"; then
                STATUS="üÜï Added"
              elif git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^D"; then
                STATUS="üóëÔ∏è Deleted"
              elif git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | grep -q "^R"; then
                STATUS="üìù Renamed"
              else
                STATUS="‚úèÔ∏è Modified"
              fi
              
              echo "- **$file** $STATUS (+$ADDED/-$DELETED)" >> pr_changes_summary.txt
            fi
          done
          
          if [ $FILES_CHANGED -gt 20 ]; then
            echo "- ... and $((FILES_CHANGED - 20)) more files" >> pr_changes_summary.txt
          fi
          
          # Generar resumen inteligente del prop√≥sito del PR
          echo "" > pr_purpose_summary.txt
          echo "## üìù PR Summary" >> pr_purpose_summary.txt
          echo "" >> pr_purpose_summary.txt
          
          # Analizar patrones en los archivos para determinar el prop√≥sito
          PURPOSE=""
          DETAILS=""
          
          # Detectar cambios en CI/CD
          if echo "$MODIFIED_FILES" | grep -q "\.github/workflows"; then
            PURPOSE="CI/CD Pipeline Configuration"
            DETAILS="This PR modifies GitHub Actions workflows for continuous integration and deployment."
          elif echo "$MODIFIED_FILES" | grep -q "Dockerfile\|docker-compose"; then
            PURPOSE="Docker Configuration"
            DETAILS="This PR updates Docker containerization setup."
          elif echo "$MODIFIED_FILES" | grep -q "package\.json\|yarn\.lock\|package-lock\.json"; then
            if [ $JS_FILES -gt 0 ]; then
              PURPOSE="Feature Development & Dependencies"
              DETAILS="This PR includes new features or updates along with dependency changes."
            else
              PURPOSE="Dependency Updates"
              DETAILS="This PR focuses on updating project dependencies."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "\.test\.\|\.spec\.\|__tests__"; then
            PURPOSE="Testing & Quality Assurance"
            DETAILS="This PR adds or improves test coverage and quality assurance."
          elif echo "$MODIFIED_FILES" | grep -q "README\|\.md$"; then
            if [ $FILES_CHANGED -eq $MD_FILES ]; then
              PURPOSE="Documentation Update"
              DETAILS="This PR focuses on improving project documentation."
            else
              PURPOSE="Feature Development with Documentation"
              DETAILS="This PR includes feature changes along with documentation updates."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "\.css\|\.scss\|\.sass\|\.less"; then
            if [ $CSS_FILES -eq $FILES_CHANGED ]; then
              PURPOSE="UI/UX Styling Updates"
              DETAILS="This PR focuses on user interface and styling improvements."
            else
              PURPOSE="Feature Development with UI Changes"
              DETAILS="This PR includes functionality changes with user interface updates."
            fi
          elif echo "$MODIFIED_FILES" | grep -q "config\|\.env\|\.yml\|\.yaml\|\.xml"; then
            PURPOSE="Configuration Updates"
            DETAILS="This PR modifies application or environment configuration."
          elif [ $JS_FILES -gt 0 ]; then
            if [ $FILES_CHANGED -le 3 ]; then
              PURPOSE="Bug Fix or Minor Enhancement"
              DETAILS="This PR addresses specific issues or makes targeted improvements."
            else
              PURPOSE="Feature Development"
              DETAILS="This PR introduces new functionality or significant enhancements."
            fi
          else
            PURPOSE="General Updates"
            DETAILS="This PR contains miscellaneous updates and improvements."
          fi
          
          # Agregar informaci√≥n espec√≠fica basada en archivos
          SPECIFIC_CHANGES=""
          if echo "$MODIFIED_FILES" | grep -q "\.github/workflows.*\.yml"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üîÑ GitHub Actions workflow automation"
          fi
          if echo "$MODIFIED_FILES" | grep -q "package\.json"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üì¶ NPM dependencies and scripts"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.js\|\.jsx\|\.ts\|\.tsx"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üíª JavaScript/TypeScript code changes"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.css\|\.scss"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üé® Styling and visual updates"
          fi
          if echo "$MODIFIED_FILES" | grep -q "\.test\.\|\.spec\."; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üß™ Test cases and quality assurance"
          fi
          if echo "$MODIFIED_FILES" | grep -q "README\|\.md"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üìö Documentation improvements"
          fi
          if echo "$MODIFIED_FILES" | grep -q "Dockerfile\|docker"; then
            SPECIFIC_CHANGES="$SPECIFIC_CHANGES\n- üê≥ Docker containerization"
          fi
          
          echo "**Purpose:** $PURPOSE" >> pr_purpose_summary.txt
          echo "" >> pr_purpose_summary.txt
          echo "$DETAILS" >> pr_purpose_summary.txt
          
          if [ ! -z "$SPECIFIC_CHANGES" ]; then
            echo "" >> pr_purpose_summary.txt
            echo "**Key Changes:**" >> pr_purpose_summary.txt
            echo -e "$SPECIFIC_CHANGES" >> pr_purpose_summary.txt
          fi
          
          # Guardar estad√≠sticas en outputs
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT
          echo "lines_added=$LINES_ADDED" >> $GITHUB_OUTPUT
          echo "lines_deleted=$LINES_DELETED" >> $GITHUB_OUTPUT
          echo "js_files=$JS_FILES" >> $GITHUB_OUTPUT
          echo "css_files=$CSS_FILES" >> $GITHUB_OUTPUT
          echo "json_files=$JSON_FILES" >> $GITHUB_OUTPUT
          echo "md_files=$MD_FILES" >> $GITHUB_OUTPUT
          echo "config_files=$CONFIG_FILES" >> $GITHUB_OUTPUT
          echo "other_files=$OTHER_FILES" >> $GITHUB_OUTPUT

      - name: Generate PR Comment
        id: copilot
        run: |
          {
            echo "ü§ñ **Automated Code Review Summary**"
            echo ""
            echo "## üìä Analysis Results"
            echo ""
            echo "### üîç ESLint Analysis"
            echo "- ‚ùå Errors: ${{ steps.eslint.outputs.eslint_errors }}"
            echo "- ‚ö†Ô∏è Warnings: ${{ steps.eslint.outputs.eslint_warnings }}"
            echo ""
            echo "### üß™ Test Results"
            echo "- ‚úÖ Passed: ${{ steps.tests.outputs.tests_passed }}"
            echo "- ‚ùå Failed: ${{ steps.tests.outputs.tests_failed }}"
            echo "- üìä Coverage: ${{ steps.tests.outputs.coverage_files }} files"
            echo ""
            echo "### üîí Security Audit"
            echo "- üö® High: ${{ steps.audit.outputs.audit_high }}"
            echo "- ‚ö†Ô∏è Moderate: ${{ steps.audit.outputs.audit_moderate }}"
            echo ""
            echo "### üíÖ Code Formatting"
            echo "- üìù Issues: ${{ steps.prettier.outputs.formatting_issues }}"
            echo ""
            echo "## üéØ Recommendations"
            echo ""
            if [ '${{ steps.eslint.outputs.eslint_errors }}' -gt 0 ]; then
              echo "- üîß Fix ESLint errors before merging"
            fi
            if [ '${{ steps.tests.outputs.tests_failed }}' -gt 0 ]; then
              echo "- üß™ Fix failing tests"
            fi
            if [ '${{ steps.audit.outputs.audit_high }}' -gt 0 ]; then
              echo "- üö® Address high security vulnerabilities"
            fi
            if [ '${{ steps.prettier.outputs.formatting_issues }}' -gt 0 ]; then
              echo "- üíÖ Run prettier to fix formatting"
            fi
          } > review_comment.txt
          
          # Convert to single line for GitHub output
          COMMENT=$(cat review_comment.txt | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "comment=$COMMENT" >> $GITHUB_OUTPUT

      - name: Post Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `${{ steps.copilot.outputs.comment }}`.replace(/\\n/g, '\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -f pr_diff.txt eslint-results.json test-results.json audit-results.json
          rm -f prettier-results.txt pr_changes_summary.txt pr_purpose_summary.txt copilot_comment.txt
          echo "Cleanup completed"

